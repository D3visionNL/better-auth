var q=(e,s="ms")=>new Date(Date.now()+(s==="sec"?e*1e3:e));import{z as x}from"zod";import{APIError as we}from"better-call";var be=x.object({id:x.string(),providerId:x.string(),accountId:x.string(),userId:x.string(),accessToken:x.string().nullish(),refreshToken:x.string().nullish(),idToken:x.string().nullish(),accessTokenExpiresAt:x.date().nullish(),refreshTokenExpiresAt:x.date().nullish(),scope:x.string().nullish(),password:x.string().nullish(),image:x.string().nullish(),createdAt:x.date().default(()=>new Date),updatedAt:x.date().default(()=>new Date)}),ve=x.object({id:x.string(),email:x.string().transform(e=>e.toLowerCase()),emailVerified:x.boolean().default(!1),name:x.string(),image:x.string().nullish(),createdAt:x.date().default(()=>new Date),updatedAt:x.date().default(()=>new Date)}),Te=x.object({id:x.string(),userId:x.string(),expiresAt:x.date(),createdAt:x.date().default(()=>new Date),updatedAt:x.date().default(()=>new Date),token:x.string(),ipAddress:x.string().nullish(),userAgent:x.string().nullish()}),ke=x.object({id:x.string(),value:x.string(),createdAt:x.date().default(()=>new Date),updatedAt:x.date().default(()=>new Date),expiresAt:x.date(),identifier:x.string()});function P(e,s){let c=s.fields,u={};for(let p in e){let g=c[p];if(!g){u[p]=e[p];continue}g.returned!==!1&&(u[p]=e[p])}return u}function V(e,s){let c={...s==="user"?e.user?.additionalFields:{},...s==="session"?e.session?.additionalFields:{}};for(let u of e.plugins||[])u.schema&&u.schema[s]&&(c={...c,...u.schema[s].fields});return c}function B(e,s){let c=V(e,"user");return P(s,{fields:c})}function D(e,s){let c=V(e,"session");return P(s,{fields:c})}function M(e,s){let c=s.hooks;async function u(o,m,t){let r=o;for(let l of c||[]){let d=l[m]?.create?.before;if(d){let i=await d(o);if(i===!1)return null;typeof i=="object"&&"data"in i&&(r=i.data)}}let n=t?await t.fn(r):null,a=!t||t.executeMainFn?await e.create({model:m,data:r}):n;for(let l of c||[]){let d=l[m]?.create?.after;d&&await d(a)}return a}async function p(o,m,t,r){let n=o;for(let d of c||[]){let i=d[t]?.update?.before;if(i){let f=await i(o);if(f===!1)return null;n=typeof f=="object"?f.data:f}}let a=r?await r.fn(n):null,l=!r||r.executeMainFn?await e.update({model:t,update:n,where:m}):a;for(let d of c||[]){let i=d[t]?.update?.after;i&&await i(l)}return l}async function g(o,m,t,r){let n=o;for(let d of c||[]){let i=d[t]?.update?.before;if(i){let f=await i(o);if(f===!1)return null;n=typeof f=="object"?f.data:f}}let a=r?await r.fn(n):null,l=!r||r.executeMainFn?await e.updateMany({model:t,update:n,where:m}):a;for(let d of c||[]){let i=d[t]?.update?.after;i&&await i(l)}return l}return{createWithHooks:u,updateWithHooks:p,updateManyWithHooks:g}}var I=Object.create(null),F=e=>globalThis.process?.env||globalThis.Deno?.env.toObject()||globalThis.__env__||(e?I:globalThis),_=new Proxy(I,{get(e,s){return F()[s]??I[s]},has(e,s){let c=F();return s in c||s in I},set(e,s,c){let u=F(!0);return u[s]=c,!0},deleteProperty(e,s){if(!s)return!1;let c=F(!0);return delete c[s],!0},ownKeys(){let e=F(!0);return Object.keys(e)}});function Y(e){return e?e!=="false":!1}var ee=typeof process<"u"&&process.env&&process.env.NODE_ENV||"";var C=ee==="test"||Y(_.TEST);function j(e,s){if(s.advanced?.ipAddress?.disableIpTracking)return null;let c="127.0.0.1";if(C)return c;let p=s.advanced?.ipAddress?.ipAddressHeaders||["x-client-ip","x-forwarded-for","cf-connecting-ip","fastly-client-ip","x-real-ip","x-cluster-client-ip","x-forwarded","forwarded-for","forwarded"],g=e instanceof Request?e.headers:e;for(let o of p){let m=g.get(o);if(typeof m=="string"){let t=m.split(",")[0].trim();if(t)return t}}return null}function N(e){try{return JSON.parse(e)}catch{return null}}import{createRandomStringGenerator as te}from"@better-auth/utils/random";var k=e=>te("a-z","A-Z","0-9")(e||32);import{z as Tt}from"zod";import{APIError as Rt}from"better-call";var O=class extends Error{constructor(s,c){super(s),this.name="BetterAuthError",this.message=s,this.cause=c,this.stack=""}};import{createHash as at}from"@better-auth/utils/hash";import{xchacha20poly1305 as dt}from"@noble/ciphers/chacha";import{bytesToHex as lt,hexToBytes as ct,utf8ToBytes as ft}from"@noble/ciphers/utils";import{managedNonce as mt}from"@noble/ciphers/webcrypto";import{createHash as $e}from"@better-auth/utils/hash";import{SignJWT as Je}from"jose";import{scryptAsync as Qe}from"@noble/hashes/scrypt";import{getRandomValues as Ye}from"uncrypto";import{hex as tt}from"@better-auth/utils/hex";import{createRandomStringGenerator as ne}from"@better-auth/utils/random";var ie=ne("a-z","0-9","A-Z","-_");var L=["info","success","warn","error","debug"];function se(e,s){return L.indexOf(s)<=L.indexOf(e)}var b={reset:"\x1B[0m",bright:"\x1B[1m",dim:"\x1B[2m",underscore:"\x1B[4m",blink:"\x1B[5m",reverse:"\x1B[7m",hidden:"\x1B[8m",fg:{black:"\x1B[30m",red:"\x1B[31m",green:"\x1B[32m",yellow:"\x1B[33m",blue:"\x1B[34m",magenta:"\x1B[35m",cyan:"\x1B[36m",white:"\x1B[37m"},bg:{black:"\x1B[40m",red:"\x1B[41m",green:"\x1B[42m",yellow:"\x1B[43m",blue:"\x1B[44m",magenta:"\x1B[45m",cyan:"\x1B[46m",white:"\x1B[47m"}},ae={info:b.fg.blue,success:b.fg.green,warn:b.fg.yellow,error:b.fg.red,debug:b.fg.magenta},oe=(e,s)=>{let c=new Date().toISOString();return`${b.dim}${c}${b.reset} ${ae[e]}${e.toUpperCase()}${b.reset} ${b.bright}[Better Auth]:${b.reset} ${s}`},E=e=>{let s=e?.disabled!==!0,c=e?.level??"error",u=(p,g,o=[])=>{if(!s||!se(c,p))return;let m=oe(p,g);if(!e||typeof e.log!="function"){p==="error"?console.error(m,...o):p==="warn"?console.warn(m,...o):console.log(m,...o);return}e.log(p==="success"?"info":p,m,...o)};return Object.fromEntries(L.map(p=>[p,(...[g,...o])=>u(p,g,o)]))},H=E();var $t=(e,s)=>{let c=s.options,u=c.secondaryStorage,p=c.session?.expiresIn||60*60*24*7,{createWithHooks:g,updateWithHooks:o,updateManyWithHooks:m}=M(e,s);return{createOAuthUser:async(t,r)=>{let n=await g({createdAt:new Date,updatedAt:new Date,...t},"user"),a=await g({...r,userId:n.id||t.id,createdAt:new Date,updatedAt:new Date},"account");return{user:n,account:a}},createUser:async t=>await g({createdAt:new Date,updatedAt:new Date,emailVerified:!1,...t,email:t.email.toLowerCase()},"user"),createAccount:async t=>await g({createdAt:new Date,updatedAt:new Date,...t},"account"),listSessions:async t=>{if(u){let n=await u.get(`active-sessions-${t}`);if(!n)return[];let a=N(n)||[],l=Date.now(),d=a.filter(f=>f.expiresAt>l),i=[];for(let f of d){let A=await u.get(f.token);if(A){let y=JSON.parse(A),w=D(s.options,{...y.session,expiresAt:new Date(y.session.expiresAt)});i.push(w)}}return i}return await e.findMany({model:"session",where:[{field:"userId",value:t}]})},listUsers:async(t,r,n,a)=>await e.findMany({model:"user",limit:t,offset:r,sortBy:n,where:a}),deleteUser:async t=>{await e.deleteMany({model:"session",where:[{field:"userId",value:t}]}),await e.deleteMany({model:"account",where:[{field:"userId",value:t}]}),await e.delete({model:"user",where:[{field:"id",value:t}]})},createSession:async(t,r,n,a)=>{let l=r instanceof Request?r.headers:r,{id:d,...i}=a||{},f={ipAddress:r&&j(r,s.options)||"",userAgent:l?.get("user-agent")||"",...i,expiresAt:n?q(60*60*24,"sec"):q(p,"sec"),userId:t,token:k(32),createdAt:new Date,updatedAt:new Date};return await g(f,"session",u?{fn:async y=>{let w=await u.get(`active-sessions-${t}`),h=[],T=Date.now();return w&&(h=N(w)||[],h=h.filter(X=>X.expiresAt>T)),h.push({token:f.token,expiresAt:T+p*1e3}),await u.set(`active-sessions-${t}`,JSON.stringify(h),p),y},executeMainFn:c.session?.storeSessionInDatabase}:void 0)},findSession:async t=>{if(u){let d=await u.get(t);if(d){let i=JSON.parse(d),f=D(s.options,{...i.session,expiresAt:new Date(i.session.expiresAt),createdAt:new Date(i.session.createdAt),updatedAt:new Date(i.session.updatedAt)}),A=B(s.options,{...i.user,createdAt:new Date(i.user.createdAt),updatedAt:new Date(i.user.updatedAt)});return{session:f,user:A}}}let r=await e.findOne({model:"session",where:[{value:t,field:"token"}]});if(!r)return null;let n=await e.findOne({model:"user",where:[{value:r.userId,field:"id"}]});if(!n)return null;let a=D(s.options,r),l=B(s.options,n);return u&&await u?.set(t,JSON.stringify({session:a,user:l}),a.expiresAt?Math.floor(((a.expiresAt instanceof Date?a.expiresAt.getTime():new Date(a.expiresAt).getTime())-Date.now())/1e3):p),{session:a,user:l}},findSessions:async t=>{if(u){let l=[];for(let d of t){let i=await u.get(d);if(i){let f=JSON.parse(i),A={session:{...f.session,expiresAt:new Date(f.session.expiresAt)},user:{...f.user,createdAt:new Date(f.user.createdAt),updatedAt:new Date(f.user.updatedAt)}};l.push(A)}}return l}let r=await e.findMany({model:"session",where:[{field:"token",value:t,operator:"in"}]}),n=r.map(l=>l.userId);if(!n.length)return[];let a=await e.findMany({model:"user",where:[{field:"id",value:n,operator:"in"}]});return r.map(l=>{let d=a.find(i=>i.id===l.userId);return d?{session:l,user:d}:null})},updateSession:async(t,r)=>await o(r,[{field:"token",value:t}],"session",u?{async fn(a){let l=await u.get(t),d=null;return l?(d={...JSON.parse(l).session,...a},d):null},executeMainFn:c.session?.storeSessionInDatabase}:void 0),deleteSession:async t=>{if(u){await u.delete(t),c.session?.storeSessionInDatabase&&await e.delete({model:"session",where:[{field:"token",value:t}]});return}await e.delete({model:"session",where:[{field:"token",value:t}]})},deleteAccounts:async t=>{await e.deleteMany({model:"account",where:[{field:"userId",value:t}]})},deleteSessions:async t=>{if(u){if(typeof t=="string"){let r=await u.get(`active-sessions-${t}`),n=r?N(r):[];if(!n)return;for(let a of n)await u.delete(a.token)}else for(let r of t)await u.get(r)&&await u.delete(r);c.session?.storeSessionInDatabase&&await e.deleteMany({model:"session",where:[{field:Array.isArray(t)?"token":"userId",value:t,operator:Array.isArray(t)?"in":void 0}]});return}await e.deleteMany({model:"session",where:[{field:Array.isArray(t)?"token":"userId",value:t,operator:Array.isArray(t)?"in":void 0}]})},findOAuthUser:async(t,r,n)=>{let a=null;if(a=await e.findOne({model:"user",where:[{value:t.toLowerCase(),field:"email"}]}),!a){let d=await e.findOne({model:"account",where:[{value:r,field:"accountId"},{value:n,field:"providerId"}]});return d?(a=await e.findOne({model:"user",where:[{value:d.userId,field:"id"}]}),{user:a,accounts:[d]}):null}let l=await e.findMany({model:"account",where:[{value:a.id,field:"userId"}]});return{user:a,accounts:l||[]}},findUserByEmail:async(t,r)=>{let n=await e.findOne({model:"user",where:[{value:t.toLowerCase(),field:"email"}]});if(!n)return null;if(r?.includeAccounts){let a=await e.findMany({model:"account",where:[{value:n.id,field:"userId"}]});return{user:n,accounts:a}}return{user:n,accounts:[]}},findUserById:async t=>await e.findOne({model:"user",where:[{field:"id",value:t}]}),linkAccount:async t=>await g({...t,createdAt:new Date,updatedAt:new Date},"account"),updateUser:async(t,r)=>await o(r,[{field:"id",value:t}],"user"),updateUserByEmail:async(t,r)=>await o(r,[{field:"email",value:t}],"user"),updatePassword:async(t,r)=>{await m({password:r},[{field:"userId",value:t},{field:"providerId",value:"credential"}],"account")},findAccounts:async t=>await e.findMany({model:"account",where:[{field:"userId",value:t}]}),findAccount:async t=>await e.findOne({model:"account",where:[{field:"accountId",value:t}]}),findAccountByUserId:async t=>await e.findMany({model:"account",where:[{field:"userId",value:t}]}),updateAccount:async(t,r)=>await o(r,[{field:"id",value:t}],"account"),createVerificationValue:async t=>await g({createdAt:new Date,updatedAt:new Date,...t},"verification"),findVerificationValue:async t=>(await e.findMany({model:"verification",where:[{field:"identifier",value:t}],sortBy:{field:"createdAt",direction:"desc"},limit:1}))[0],deleteVerificationValue:async t=>{await e.delete({model:"verification",where:[{field:"id",value:t}]})},deleteVerificationByIdentifier:async t=>{await e.delete({model:"verification",where:[{field:"identifier",value:t}]})},updateVerificationValue:async(t,r)=>await o(r,[{field:"id",value:t}],"verification")}};var Wt=(e,s)=>({type:e,...s});var v=e=>{let s=e.plugins?.reduce((t,r)=>{let n=r.schema;if(!n)return t;for(let[a,l]of Object.entries(n))t[a]={fields:{...t[a]?.fields,...l.fields},modelName:l.modelName||a};return t},{}),c=e.rateLimit?.storage==="database",u={rateLimit:{modelName:e.rateLimit?.modelName||"rateLimit",fields:{key:{type:"string",fieldName:e.rateLimit?.fields?.key||"key"},count:{type:"number",fieldName:e.rateLimit?.fields?.count||"count"},lastRequest:{type:"number",fieldName:e.rateLimit?.fields?.lastRequest||"lastRequest"}}}},{user:p,session:g,account:o,...m}=s||{};return{user:{modelName:e.user?.modelName||"user",fields:{name:{type:"string",required:!0,fieldName:e.user?.fields?.name||"name"},email:{type:"string",unique:!0,required:!0,fieldName:e.user?.fields?.email||"email"},emailVerified:{type:"boolean",defaultValue:()=>!1,required:!0,fieldName:e.user?.fields?.emailVerified||"emailVerified"},image:{type:"string",required:!1,fieldName:e.user?.fields?.image||"image"},createdAt:{type:"date",defaultValue:()=>new Date,required:!0,fieldName:e.user?.fields?.createdAt||"createdAt"},updatedAt:{type:"date",defaultValue:()=>new Date,required:!0,fieldName:e.user?.fields?.updatedAt||"updatedAt"},...p?.fields,...e.user?.additionalFields},order:1},session:{modelName:e.session?.modelName||"session",fields:{expiresAt:{type:"date",required:!0,fieldName:e.session?.fields?.expiresAt||"expiresAt"},token:{type:"string",required:!0,fieldName:e.session?.fields?.token||"token",unique:!0},createdAt:{type:"date",required:!0,fieldName:e.session?.fields?.createdAt||"createdAt"},updatedAt:{type:"date",required:!0,fieldName:e.session?.fields?.updatedAt||"updatedAt"},ipAddress:{type:"string",required:!1,fieldName:e.session?.fields?.ipAddress||"ipAddress"},userAgent:{type:"string",required:!1,fieldName:e.session?.fields?.userAgent||"userAgent"},userId:{type:"string",fieldName:e.session?.fields?.userId||"userId",references:{model:e.user?.modelName||"user",field:"id",onDelete:"cascade"},required:!0},...g?.fields,...e.session?.additionalFields},order:2},account:{modelName:e.account?.modelName||"account",fields:{accountId:{type:"string",required:!0,fieldName:e.account?.fields?.accountId||"accountId"},providerId:{type:"string",required:!0,fieldName:e.account?.fields?.providerId||"providerId"},userId:{type:"string",references:{model:e.user?.modelName||"user",field:"id",onDelete:"cascade"},required:!0,fieldName:e.account?.fields?.userId||"userId"},accessToken:{type:"string",required:!1,fieldName:e.account?.fields?.accessToken||"accessToken"},refreshToken:{type:"string",required:!1,fieldName:e.account?.fields?.refreshToken||"refreshToken"},idToken:{type:"string",required:!1,fieldName:e.account?.fields?.idToken||"idToken"},accessTokenExpiresAt:{type:"date",required:!1,fieldName:e.account?.fields?.accessTokenExpiresAt||"accessTokenExpiresAt"},refreshTokenExpiresAt:{type:"date",required:!1,fieldName:e.account?.fields?.accessTokenExpiresAt||"refreshTokenExpiresAt"},scope:{type:"string",required:!1,fieldName:e.account?.fields?.scope||"scope"},password:{type:"string",required:!1,fieldName:e.account?.fields?.password||"password"},createdAt:{type:"date",required:!0,fieldName:e.account?.fields?.createdAt||"createdAt"},updatedAt:{type:"date",required:!0,fieldName:e.account?.fields?.updatedAt||"updatedAt"},...o?.fields},order:3},verification:{modelName:e.verification?.modelName||"verification",fields:{identifier:{type:"string",required:!0,fieldName:e.verification?.fields?.identifier||"identifier"},value:{type:"string",required:!0,fieldName:e.verification?.fields?.value||"value"},expiresAt:{type:"date",required:!0,fieldName:e.verification?.fields?.expiresAt||"expiresAt"},createdAt:{type:"date",required:!1,defaultValue:()=>new Date,fieldName:e.verification?.fields?.createdAt||"createdAt"},updatedAt:{type:"date",required:!1,defaultValue:()=>new Date,fieldName:e.verification?.fields?.updatedAt||"updatedAt"}},order:4},...m,...c?u:{}}};import{z as R}from"zod";function Zt(e){return R.object({...Object.keys(e).reduce((c,u)=>{let p=e[u];if(!p)return c;if(p.type==="string[]"||p.type==="number[]")return{...c,[u]:R.array(p.type==="string[]"?R.string():R.number())};if(Array.isArray(p.type))return{...c,[u]:R.any()};let g=R[p.type]();return p?.required===!1&&(g=g.optional()),p?.returned===!1?c:{...c,[u]:g}},{})})}import{Kysely as $,MssqlDialect as de}from"kysely";import{MysqlDialect as K,PostgresDialect as W,SqliteDialect as J}from"kysely";function z(e){if(!e)return null;if("dialect"in e)return z(e.dialect);if("createDriver"in e){if(e instanceof J)return"sqlite";if(e instanceof K)return"mysql";if(e instanceof W)return"postgres";if(e instanceof de)return"mssql"}return"aggregate"in e?"sqlite":"getConnection"in e?"mysql":"connect"in e?"postgres":null}var U=async e=>{let s=e.database;if(!s)return{kysely:null,databaseType:null};if("db"in s)return{kysely:s.db,databaseType:s.type};if("dialect"in s)return{kysely:new $({dialect:s.dialect}),databaseType:s.type};let c,u=z(s);return"createDriver"in s&&(c=s),"aggregate"in s&&(c=new J({database:s})),"getConnection"in s&&(c=new K(s)),"connect"in s&&(c=new W({pool:s})),{kysely:c?new $({dialect:c}):null,databaseType:u}};function S(e,s,c){return c==="update"?e:e==null&&s.defaultValue?typeof s.defaultValue=="function"?s.defaultValue():s.defaultValue:e}var ue=(e,s,c)=>{let u=v(s);function p(r,n){if(n==="id")return n;let a=u[r].fields[n];return a||console.log("Field not found",r,n),a.fieldName||n}function g(r,n,a){let{type:l="sqlite"}=c||{},d=u[n].fields[a];return d.type==="boolean"&&l==="sqlite"&&r!==null&&r!==void 0?r?1:0:d.type==="date"&&r&&r instanceof Date&&l==="sqlite"?r.toISOString():r}function o(r,n,a){let{type:l="sqlite"}=c||{},d=u[n].fields[a];return d.type==="boolean"&&l==="sqlite"&&r!==null?r===1:d.type==="date"&&r?new Date(r):r}function m(r){return u[r].modelName}let t=s?.advanced?.generateId===!1;return{transformInput(r,n,a){let l=t||a==="update"?{}:{id:s.advanced?.generateId?s.advanced.generateId({model:n}):r.id||k()},d=u[n].fields;for(let i in d){let f=r[i];l[d[i].fieldName||i]=S(g(f,n,i),d[i],a)}return l},transformOutput(r,n,a=[]){if(!r)return null;let l=r.id?a.length===0||a.includes("id")?{id:r.id}:{}:{},d=u[n].fields;for(let i in d){if(a.length&&!a.includes(i))continue;let f=d[i];f&&(l[i]=o(r[f.fieldName||i],n,i))}return l},convertWhereClause(r,n){if(!n)return{and:null,or:null};let a={and:[],or:[]};return n.forEach(l=>{let{field:d,value:i,operator:f="=",connector:A="AND"}=l,y=p(r,d),w=h=>f.toLowerCase()==="in"?h(y,"in",Array.isArray(i)?i:[i]):f==="contains"?h(y,"like",`%${i}%`):f==="starts_with"?h(y,"like",`${i}%`):f==="ends_with"?h(y,"like",`%${i}`):f==="eq"?h(y,"=",i):f==="ne"?h(y,"<>",i):f==="gt"?h(y,">",i):f==="gte"?h(y,">=",i):f==="lt"?h(y,"<",i):f==="lte"?h(y,"<=",i):h(y,f,i);A==="OR"?a.or.push(w):a.and.push(w)}),{and:a.and.length?a.and:null,or:a.or.length?a.or:null}},async withReturning(r,n,a,l){let d;if(c?.type!=="mysql")d=await n.returningAll().executeTakeFirst();else{await n.execute();let i=r.id?"id":l[0].field?l[0].field:"id",f=r[i]||l[0].value;d=await e.selectFrom(m(a)).selectAll().where(p(a,i),"=",f).executeTakeFirst()}return d},getModelName:m,getField:p}},G=(e,s)=>c=>{let{transformInput:u,withReturning:p,transformOutput:g,convertWhereClause:o,getModelName:m,getField:t}=ue(e,c,s);return{id:"kysely",async create(r){let{model:n,data:a,select:l}=r,d=u(a,n,"create"),i=e.insertInto(m(n)).values(d);return g(await p(d,i,n,[]),n,l)},async findOne(r){let{model:n,where:a,select:l}=r,{and:d,or:i}=o(n,a),f=e.selectFrom(m(n)).selectAll();d&&(f=f.where(y=>y.and(d.map(w=>w(y))))),i&&(f=f.where(y=>y.or(i.map(w=>w(y)))));let A=await f.executeTakeFirst();return A?g(A,n,l):null},async findMany(r){let{model:n,where:a,limit:l,offset:d,sortBy:i}=r,{and:f,or:A}=o(n,a),y=e.selectFrom(m(n));f&&(y=y.where(h=>h.and(f.map(T=>T(h))))),A&&(y=y.where(h=>h.or(A.map(T=>T(h))))),y=y.limit(l||100),d&&(y=y.offset(d)),i&&(y=y.orderBy(t(n,i.field),i.direction));let w=await y.selectAll().execute();return w?w.map(h=>g(h,n)):[]},async update(r){let{model:n,where:a,update:l}=r,{and:d,or:i}=o(n,a),f=u(l,n,"update"),A=e.updateTable(m(n)).set(f);return d&&(A=A.where(w=>w.and(d.map(h=>h(w))))),i&&(A=A.where(w=>w.or(i.map(h=>h(w))))),await g(await p(f,A,n,a),n)},async updateMany(r){let{model:n,where:a,update:l}=r,{and:d,or:i}=o(n,a),f=u(l,n,"update"),A=e.updateTable(m(n)).set(f);return d&&(A=A.where(w=>w.and(d.map(h=>h(w))))),i&&(A=A.where(w=>w.or(i.map(h=>h(w))))),(await A.execute()).length},async delete(r){let{model:n,where:a}=r,{and:l,or:d}=o(n,a),i=e.deleteFrom(m(n));l&&(i=i.where(f=>f.and(l.map(A=>A(f))))),d&&(i=i.where(f=>f.or(d.map(A=>A(f))))),await i.execute()},async deleteMany(r){let{model:n,where:a}=r,{and:l,or:d}=o(n,a),i=e.deleteFrom(m(n));return l&&(i=i.where(f=>f.and(l.map(A=>A(f))))),d&&(i=i.where(f=>f.or(d.map(A=>A(f))))),(await i.execute()).length},options:s}};var le=e=>{let s=v(e);function c(u,p){return p==="id"?p:s[u].fields[p].fieldName||p}return{transformInput(u,p,g){let o=g==="update"?{}:{id:e.advanced?.generateId?e.advanced.generateId({model:p}):u.id||k()},m=s[p].fields;for(let t in m){let r=u[t];r===void 0&&!m[t].defaultValue||(o[m[t].fieldName||t]=S(r,m[t],g))}return o},transformOutput(u,p,g=[]){if(!u)return null;let o=u.id||u._id?g.length===0||g.includes("id")?{id:u.id}:{}:{},m=s[p].fields;for(let t in m){if(g.length&&!g.includes(t))continue;let r=m[t];r&&(o[t]=u[r.fieldName||t])}return o},convertWhereClause(u,p,g){return p.filter(o=>u.every(m=>{let{field:t,value:r,operator:n}=m,a=c(g,t);if(n==="in"){if(!Array.isArray(r))throw new Error("Value must be an array");return r.includes(o[a])}else return n==="contains"?o[a].includes(r):n==="starts_with"?o[a].startsWith(r):n==="ends_with"?o[a].endsWith(r):o[a]===r}))},getField:c}},Z=e=>s=>{let{transformInput:c,transformOutput:u,convertWhereClause:p,getField:g}=le(s);return{id:"memory",create:async({model:o,data:m})=>{let t=c(m,o,"create");return e[o].push(t),u(t,o)},findOne:async({model:o,where:m,select:t})=>{let r=e[o],a=p(m,r,o)[0]||null;return u(a,o,t)},findMany:async({model:o,where:m,sortBy:t,limit:r,offset:n})=>{let a=e[o];return m&&(a=p(m,a,o)),t&&(a=a.sort((l,d)=>{let i=g(o,t.field);return t.direction==="asc"?l[i]>d[i]?1:-1:l[i]<d[i]?1:-1})),n!==void 0&&(a=a.slice(n)),r!==void 0&&(a=a.slice(0,r)),a.map(l=>u(l,o))},update:async({model:o,where:m,update:t})=>{let r=e[o],n=p(m,r,o);return n.forEach(a=>{Object.assign(a,c(t,o,"update"))}),u(n[0],o)},delete:async({model:o,where:m})=>{let t=e[o],r=p(m,t,o);e[o]=t.filter(n=>!r.includes(n))},deleteMany:async({model:o,where:m})=>{let t=e[o],r=p(m,t,o),n=0;return e[o]=t.filter(a=>r.includes(a)?(n++,!1):!r.includes(a)),n},updateMany(o){let{model:m,where:t,update:r}=o,n=e[m],a=p(t,n,m);return a.forEach(l=>{Object.assign(l,r)}),a[0]||null}}};async function vr(e){if(!e.database){let u=v(e),p=Object.keys(u).reduce((g,o)=>(g[o]=[],g),{});return H.warn("No database configuration provided. Using memory adapter in development"),Z(p)(e)}if(typeof e.database=="function")return e.database(e);let{kysely:s,databaseType:c}=await U(e);if(!s)throw new O("Failed to initialize database adapter");return G(s,{type:c||"sqlite"})(e)}function Tr(e,s){let c=s.id?{id:s.id}:{};for(let u in e){let p=e[u],g=s[u];g!==void 0&&(c[p.fieldName||u]=g)}return c}function kr(e,s){if(!s)return null;let c={id:s.id};for(let[u,p]of Object.entries(e))c[u]=s[p.fieldName||u];return c}function Q(e){let s=v(e),c={};for(let u in s){let p=s[u],g=p.fields,o={};if(Object.entries(g).forEach(([m,t])=>{if(o[t.fieldName||m]=t,t.references){let r=s[t.references.model];r&&(o[t.fieldName||m].references={model:r.modelName,field:t.references.field})}}),c[p.modelName]){c[p.modelName].fields={...c[p.modelName].fields,...o};continue}c[p.modelName]={fields:o,order:p.order||1/0}}return c}var ce={string:["character varying","text"],number:["int4","integer","bigint","smallint","numeric","real","double precision"],boolean:["bool","boolean"],date:["timestamp","date"]},fe={string:["varchar","text"],number:["integer","int","bigint","smallint","decimal","float","double"],boolean:["boolean","tinyint"],date:["timestamp","datetime","date"]},pe={string:["TEXT"],number:["INTEGER","REAL"],boolean:["INTEGER","BOOLEAN"],date:["DATE","INTEGER"]},me={string:["nvarchar","varchar"],number:["int","bigint","smallint","decimal","float","double"],boolean:["bit","boolean"],date:["datetime","date"]},ye={postgres:ce,mysql:fe,sqlite:pe,mssql:me};function ge(e,s,c){if(s==="string[]"||s==="number[]")return e.toLowerCase().includes("json");let u=ye[c];return(Array.isArray(s)?u.string.map(o=>o.toLowerCase()):u[s].map(o=>o.toLowerCase())).includes(e.toLowerCase())}async function Ur(e){let s=Q(e),c=E(e.logger),{kysely:u,databaseType:p}=await U(e);p||(c.warn("Could not determine database type, defaulting to sqlite. Please provide a type in the database options to avoid this."),p="sqlite"),u||(c.error("Only kysely adapter is supported for migrations. You can use `generate` command to generate the schema, if you're using a different adapter."),process.exit(1));let g=await u.introspection.getTables(),o=[],m=[];for(let[l,d]of Object.entries(s)){let i=g.find(A=>A.name===l);if(!i){let A=o.findIndex(h=>h.table===l),y={table:l,fields:d.fields,order:d.order||1/0},w=o.findIndex(h=>(h.order||1/0)>y.order);w===-1?A===-1?o.push(y):o[A].fields={...o[A].fields,...d.fields}:o.splice(w,0,y);continue}let f={};for(let[A,y]of Object.entries(d.fields)){let w=i.columns.find(h=>h.name===A);if(!w){f[A]=y;continue}ge(w.dataType,y.type,p)||c.warn(`Field ${A} in table ${l} has a different type in the database. Expected ${y.type} but got ${w.dataType}.`)}Object.keys(f).length>0&&m.push({table:l,fields:f,order:d.order||1/0})}let t=[];function r(l){let d=l.type,i={string:{sqlite:"text",postgres:"text",mysql:l.unique?"varchar(255)":l.references?"varchar(36)":"text",mssql:"text"},boolean:{sqlite:"integer",postgres:"boolean",mysql:"boolean",mssql:"boolean"},number:{sqlite:"integer",postgres:"integer",mysql:"integer",mssql:"integer"},date:{sqlite:"date",postgres:"timestamp",mysql:"datetime",mssql:"datetime"}};return p==="sqlite"&&(d==="string[]"||d==="number[]")?"text":d==="string[]"||d==="number[]"?"jsonb":Array.isArray(d)?"text":i[d][p||"sqlite"]}if(m.length)for(let l of m)for(let[d,i]of Object.entries(l.fields)){let f=r(i),A=u.schema.alterTable(l.table).addColumn(d,f,y=>(y=i.required!==!1?y.notNull():y,i.references&&(y=y.references(`${i.references.model}.${i.references.field}`)),i.unique&&(y=y.unique()),y));t.push(A)}if(o.length)for(let l of o){let d=u.schema.createTable(l.table).addColumn("id",p==="mysql"?"varchar(36)":"text",i=>i.primaryKey().notNull());for(let[i,f]of Object.entries(l.fields)){let A=r(f);d=d.addColumn(i,A,y=>(y=f.required!==!1?y.notNull():y,f.references&&(y=y.references(`${f.references.model}.${f.references.field}`)),f.unique&&(y=y.unique()),y))}t.push(d)}async function n(){for(let l of t)await l.execute()}async function a(){return t.map(d=>d.compile().sql).join(`;

`)}return{toBeCreated:o,toBeAdded:m,runMigrations:n,compileMigrations:a}}export{kr as convertFromDB,Tr as convertToDB,Wt as createFieldAttribute,$t as createInternalAdapter,vr as getAdapter,v as getAuthTables,Ur as getMigrations,Q as getSchema,M as getWithHooks,ge as matchType,Zt as toZodSchema};
